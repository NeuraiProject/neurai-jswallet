{"mappings":"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","sources":["src/neuraiWallet.ts","src/contants.ts","src/blockchain/Transactor.ts","src/blockchain/blockchain.ts","src/Errors.ts","src/blockchain/sweep.ts"],"sourcesContent":["import { getRPC, methods } from \"@neuraiproject/neurai-rpc\";\nimport NeuraiKey from \"@neuraiproject/neurai-key\";\nimport {\n  ChainType,\n  IAddressDelta,\n  IAddressMetaData,\n  ISend,\n  ISendInternalProps,\n  ISendResult,\n  SweepResult,\n} from \"./Types\";\nimport { ONE_FULL_COIN } from \"./contants\";\n\nimport * as Transactor from \"./blockchain/Transactor\";\n\nimport { sweep } from \"./blockchain/sweep\";\n\nconst URL_MAINNET = \"https://xna-rpc-mainnet.ting.finance/rpc\";\nconst URL_TESTNET = \"https://xna-rpc-testnet.ting.finance/rpc\";\n\n//Avoid singleton (anti-pattern)\n//Meaning multiple instances of the wallet must be able to co-exist\n\nexport class Wallet {\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\n  _mnemonic = \"\";\n  network: ChainType = \"xna\";\n  addressObjects: Array<IAddressMetaData> = [];\n  receiveAddress = \"\";\n  changeAddress = \"\";\n  addressPosition = 0;\n  baseCurrency = \"XNA\"; //Default is XNA but it could be EVR\n  offlineMode = false;\n  setBaseCurrency(currency: string) {\n    this.baseCurrency = currency;\n  }\n  getBaseCurrency() {\n    return this.baseCurrency;\n  }\n  /**\n   * Sweeping a private key means to send all the funds the address holds to your your wallet.\n   * The private key you sweep do not become a part of your wallet.\n   *\n   * NOTE: the address you sweep needs to cointain enough XNA to pay for the transaction\n   *\n   * @param WIF the private key of the address that you want move funds from\n   * @returns either a string, that is the transaction id or null if there were no funds to send\n   */\n  sweep(WIF: string, onlineMode: boolean): Promise<SweepResult> {\n    const wallet = this;\n\n    return sweep(WIF, wallet, onlineMode);\n  }\n  getAddressObjects() {\n    return this.addressObjects;\n  }\n  getAddresses(): Array<string> {\n    const addresses = this.addressObjects.map((obj) => {\n      return obj.address;\n    });\n    return addresses;\n  }\n\n  async init(options: IOptions) {\n    let username = \"anonymous\";\n    let password = \"anonymous\";\n    let url = URL_MAINNET;\n\n    //VALIDATION\n    if (!options) {\n      throw Error(\"option argument is mandatory\");\n    }\n\n    if (options.offlineMode === true) {\n      this.offlineMode = true;\n    }\n    if (!options.mnemonic) {\n      throw Error(\"option.mnemonic is mandatory\");\n    }\n\n    url = options.rpc_url || url;\n    password = options.rpc_password || url;\n    username = options.rpc_username || url;\n\n    if (options.network) {\n      this.network = options.network;\n      this.setBaseCurrency(getBaseCurrencyByNetwork(options.network));\n    }\n    if (options.network === \"xna-test\" && !options.rpc_url) {\n      url = URL_TESTNET;\n    }\n\n    this.rpc = getRPC(username, password, url);\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\n    //TODO improve performance by creating blocks of 20 addresses and check history for all 20 at once\n    //That is one history lookup intead of 20\n    this._mnemonic = options.mnemonic;\n\n    const ACCOUNT = 0;\n\n    //Should we create an extra amount of addresses at startup?\n    if (options.minAmountOfAddresses) {\n      for (let i = 0; i < options.minAmountOfAddresses; i++) {\n        const o = NeuraiKey.getAddressPair(\n          this.network,\n          this._mnemonic,\n          ACCOUNT,\n          this.addressPosition\n        );\n        this.addressObjects.push(o.external);\n        this.addressObjects.push(o.internal);\n        this.addressPosition++;\n      }\n    }\n\n    let isLast20ExternalAddressesUnused = false;\n    while (isLast20ExternalAddressesUnused === false) {\n      const tempAddresses = [] as string[];\n\n      for (let i = 0; i < 20; i++) {\n        const o = NeuraiKey.getAddressPair(\n          this.network,\n          this._mnemonic,\n          ACCOUNT,\n          this.addressPosition\n        );\n        this.addressObjects.push(o.external);\n        this.addressObjects.push(o.internal);\n        this.addressPosition++;\n\n        tempAddresses.push(o.external.address + \"\");\n        tempAddresses.push(o.internal.address + \"\");\n      }\n\n      if (this.offlineMode === true) {\n        //BREAK generation of addresses and do NOT check history on the network\n        isLast20ExternalAddressesUnused = true;\n      } else {\n        //If no history, break\n        isLast20ExternalAddressesUnused =\n          false === (await this.hasHistory(tempAddresses));\n      }\n    }\n  }\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\n    const includeAssets = true;\n    const obj = {\n      addresses,\n    };\n\n    const asdf = (await this.rpc(methods.getaddressbalance, [\n      obj,\n      includeAssets,\n    ])) as any;\n\n    //@ts-ignore\n    const hasReceived = Object.values(asdf).find((asset) => asset.received > 0);\n\n    return !!hasReceived;\n  }\n\n  async _getFirstUnusedAddress(external: boolean) {\n    //First, check if lastReceivedAddress\n    if (external === true && this.receiveAddress) {\n      const asdf = await this.hasHistory([this.receiveAddress]);\n      if (asdf === false) {\n        return this.receiveAddress;\n      }\n    }\n    if (external === false && this.changeAddress) {\n      const asdf = await this.hasHistory([this.changeAddress]);\n      if (asdf === false) {\n        return this.changeAddress;\n      }\n    }\n\n    //First make a list of relevant addresses, either external (even) or change (odd)\n    const addresses: string[] = [];\n\n    this.getAddresses().map(function (address: string, index: number) {\n      if (external === true && index % 2 === 0) {\n        addresses.push(address);\n      } else if (external === false && index % 2 !== 0) {\n        addresses.push(address);\n      }\n    });\n\n    //Use BINARY SEARCH\n\n    // Binary search implementation to find the first item with `history` set to false\n    const binarySearch = async (_addresses: string[]) => {\n      let low = 0;\n      let high = _addresses.length - 1;\n      let result = \"\";\n\n      while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const addy = _addresses[mid];\n\n        const hasHistory = await this.hasHistory([addy]);\n        if (hasHistory === false) {\n          result = addy;\n          high = mid - 1; // Continue searching towards the left\n        } else {\n          low = mid + 1; // Continue searching towards the right\n        }\n      }\n\n      return result;\n    };\n\n    const result = await binarySearch(addresses);\n\n    if (!result) {\n      //IF we have not found one, return the first address\n      return addresses[0];\n    }\n    if (external === true) {\n      this.receiveAddress = result;\n    } else {\n      this.changeAddress = result;\n    }\n\n    return result;\n    /*\n    //even addresses are external, odd address are internal/changes\n    for (let counter = 0; counter < addresses.length; counter++) {\n      //Internal addresses should be even numbers\n      if (external && counter % 2 !== 0) {\n        continue;\n      }\n      //Internal addresses should be odd numbers\n      if (external === false && counter % 2 === 0) {\n        continue;\n      }\n      const address = addresses[counter];\n\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\n\n      const hasHistory = await this.hasHistory([address]);\n\n      if (hasHistory === false) {\n        if (external === true) {\n          this.receiveAddress = address;\n        }\n        if (external === false) {\n          this.changeAddress = address;\n        }\n        return address;\n      }\n    }\n*/\n  }\n\n  async getHistory(): Promise<IAddressDelta[]> {\n    const assetName = \"\"; //Must be empty string, NOT \"*\"\n    const addresses = this.getAddresses();\n    const deltas = this.rpc(methods.getaddressdeltas, [\n      { addresses, assetName },\n    ]);\n    //@ts-ignore\n    const addressDeltas: IAddressDelta[] = deltas as IAddressDelta[];\n    return addressDeltas;\n  }\n  async getMempool(): Promise<IAddressDelta[]> {\n    const method = methods.getaddressmempool;\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    return this.rpc(method, params) as Promise<IAddressDelta[]>;\n  }\n  async getReceiveAddress() {\n    const isExternal = true;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n\n  async getChangeAddress() {\n    const isExternal = false;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n  /**\n   *\n   * @param assetName if present, only return UTXOs for that asset, otherwise for all assets\n   * @returns UTXOs for assets\n   */\n  async getAssetUTXOs(assetName?: string) {\n    //If no asset name, set to wildcard, meaning all assets\n    const _assetName = !assetName ? \"*\" : assetName;\n    const chainInfo = false;\n    const params = [\n      { addresses: this.getAddresses(), chainInfo, assetName: _assetName },\n    ];\n\n    return this.rpc(methods.getaddressutxos, params);\n  }\n  async getUTXOs() {\n    return this.rpc(methods.getaddressutxos, [\n      { addresses: this.getAddresses() },\n    ]);\n  }\n\n  getPrivateKeyByAddress(address: string) {\n    const f = this.addressObjects.find((a) => a.address === address);\n\n    if (!f) {\n      return undefined;\n    }\n    return f.WIF;\n  }\n\n  async send(options: ISend): Promise<ISendResult> {\n    const { amount, toAddress } = options;\n    let { assetName } = options;\n\n    if (!assetName) {\n      assetName = this.baseCurrency;\n    }\n    const changeAddress = await this.getChangeAddress();\n\n    //Find the first change address after change address (emergency take the first).\n    const addresses = this.getAddresses();\n    let index = addresses.indexOf(changeAddress);\n    if (index > addresses.length - 2) {\n      index = 1;\n    }\n    if (index === -1) {\n      index = 1;\n    }\n    const changeAddressAssets = addresses[index + 2];\n\n    if (changeAddressAssets === changeAddress) {\n      throw Error(\n        \"Internal Error, changeAddress and changeAddressAssets cannot be the same\"\n      );\n    }\n\n    //Validation\n    if (!toAddress) {\n      throw Error(\"Wallet.send toAddress is mandatory\");\n    }\n    if (!amount) {\n      throw Error(\"Wallet.send amount is mandatory\");\n    }\n\n    if (changeAddress === toAddress) {\n      throw Error(\n        \"Wallet.send change address cannot be the same as toAddress \" +\n          changeAddress\n      );\n    }\n    if (changeAddressAssets === toAddress) {\n      throw Error(\n        \"Wallet.send change address for assets cannot be the same as toAddress \" +\n          changeAddressAssets\n      );\n    }\n    const props: ISendInternalProps = {\n      fromAddressObjects: this.addressObjects,\n      amount,\n      assetName,\n      baseCurrency: this.baseCurrency,\n      changeAddress,\n      changeAddressAssets,\n      network: this.network,\n      rpc: this.rpc,\n      toAddress,\n    };\n    return Transactor.send(props);\n  }\n\n  async getAssets() {\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\n\n    //Remove baseCurrency\n    const result = balance.filter((obj) => {\n      return obj.assetName !== this.baseCurrency;\n    });\n    return result;\n  }\n  async getBalance() {\n    const includeAssets = false;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\n\n    return balance.balance / ONE_FULL_COIN;\n  }\n}\n\nexport default {\n  createInstance,\n};\nexport async function createInstance(options: IOptions): Promise<Wallet> {\n  const wallet = new Wallet();\n  await wallet.init(options);\n  return wallet;\n}\n\nexport function getBaseCurrencyByNetwork(network: ChainType): string {\n  const map = {\n    evr: \"EVR\",\n    \"evr-test\": \"EVR\",\n    xna: \"XNA\",\n    \"xna-test\": \"XNA\",\n  };\n  return map[network];\n}\nexport interface IOptions {\n  mnemonic: string;\n  minAmountOfAddresses?: number;\n  network?: ChainType;\n  rpc_username?: string;\n  rpc_password?: string;\n  rpc_url?: string;\n\n  offlineMode?: boolean;\n}\n","export const ONE_FULL_COIN = 1e8;","import {\n  IAddressMetaData,\n  ISendInternalProps,\n  ISendResult,\n  IUTXO,\n  IVout,\n  IVout_when_creating_transactions,\n  RPCType,\n  TPrivateKey,\n} from \"../Types\";\nimport { sign } from \"@neuraiproject/neurai-sign-transaction\";\nimport * as blockchain from \"./blockchain\";\n\nimport { ITransaction } from \"../Types\";\nimport { ONE_FULL_COIN } from \"../contants\";\nimport {\n  InsufficientFundsError,\n  InvalidAddressError,\n  ValidationError,\n} from \"../Errors\";\n\nasync function isValidAddress(rpc: RPCType, address: string) {\n  const obj = await blockchain.validateAddress(rpc, address);\n  return obj.isvalid === true;\n}\n\nfunction sumOfUTXOs(UTXOs: Array<IUTXO>) {\n  let unspentNeuraiAmount = 0;\n  UTXOs.map(function (item) {\n    const newValue = item.satoshis / 1e8;\n    unspentNeuraiAmount = unspentNeuraiAmount + newValue;\n  });\n  return unspentNeuraiAmount;\n}\n/*\n\n    \"Chicken and egg\" situation.\n    We need to calculate how much we shall pay in fees based on the size of the transaction.\n    When adding inputs/outputs for the fee, we increase the fee.\n\n    Lets start by first assuming that we will pay 1 XNA in fee (that is sky high).\n    Than we check the size of the transaction and then we just adjust the change output so the fee normalizes\n*/\nasync function getFee(\n  rpc: RPCType,\n  inputs: Array<IVout_when_creating_transactions>,\n  outputs: Array<IVout>\n): Promise<number> {\n  const ONE_KILOBYTE = 1024;\n  //Create a raw transaction to get an aproximation for transaction size.\n  const raw = await blockchain.createRawTransaction(rpc, inputs, outputs);\n\n  //Get the length of the string bytes not the string\n  //This is NOT the exact size since we will add an output for the change address to the transaction\n  //We add 20% to the size, to cover extra input for fee\n  const size = (Buffer.from(raw).length / ONE_KILOBYTE) * 1.2;\n  let fee = 0.02;\n  //Ask the \"blockchain\" **estimatesmartfee**\n  try {\n    const confirmationTarget = 100;\n    const asdf = await rpc(\"estimatesmartfee\", [confirmationTarget]);\n    if (!asdf.errors) {\n      fee = asdf.feerate;\n    }\n  } catch (e) {}\n\n  const result = fee * Math.max(1, size);\n  return result;\n}\n\nfunction getDefaultSendResult() {\n  const sendResult: ISendResult = {\n    transactionId: \"undefined\",\n    debug: {\n      assetName: \"\",\n      assetUTXOs: [],\n      amount: 0,\n      fee: 0,\n      inputs: [],\n      outputs: null,\n      xnaChangeAmount: 0,\n      xnaUTXOs: [],\n      unspentXNAAmount: \"\",\n      xnaAmount: 0,\n    },\n  };\n  return sendResult;\n}\nexport async function send(options: ISendInternalProps): Promise<ISendResult> {\n  const {\n    amount,\n    assetName,\n    baseCurrency,\n    changeAddress,\n    changeAddressAssets,\n    fromAddressObjects,\n    network,\n    toAddress,\n    rpc,\n  } = options;\n\n  const sendResult = getDefaultSendResult();\n  sendResult.debug.amount = amount;\n  const MAX_FEE = 4;\n\n  const isAssetTransfer = assetName !== baseCurrency;\n\n  //VALIDATION\n  if ((await isValidAddress(rpc, toAddress)) === false) {\n    throw new InvalidAddressError(\"Invalid address \" + toAddress);\n  }\n  if (amount < 0) {\n    throw new ValidationError(\"Cant send less than zero\");\n  }\n\n  const addresses = fromAddressObjects.map((a) => a.address);\n\n  //Do we have enough of the asset?\n  if (isAssetTransfer === true) {\n    if (!changeAddressAssets) {\n      throw new ValidationError(\"No changeAddressAssets\");\n    }\n    const b = await blockchain.getBalance(rpc, addresses);\n    const a = b.find((asset) => asset.assetName === assetName);\n    if (!a) {\n      throw new InsufficientFundsError(\"You do not have any \" + assetName);\n    }\n    const balance = a.balance / ONE_FULL_COIN;\n    if (balance < amount) {\n      throw new InsufficientFundsError(\n        \"You do not have \" + amount + \" \" + assetName\n      );\n    }\n  }\n\n  let allBaseCurrencyUTXOs = await blockchain.getBaseCurrencyUTXOs(\n    rpc,\n    addresses\n  );\n\n  //Remove UTXOs that are currently in mempool\n  const mempool = await blockchain.getMempool(rpc);\n\n  allBaseCurrencyUTXOs = allBaseCurrencyUTXOs.filter(\n    (UTXO) => isUTXOInMempool(mempool, UTXO) === false\n  );\n\n  const enoughBaseCurrencyUTXOs = getEnoughUTXOs(\n    allBaseCurrencyUTXOs,\n    isAssetTransfer ? 1 : amount + MAX_FEE\n  );\n\n  //Sum up the whole unspent amount\n  let unspentBaseCurrencyAmount = sumOfUTXOs(enoughBaseCurrencyUTXOs);\n  if (unspentBaseCurrencyAmount <= 0) {\n    throw new InsufficientFundsError(\n      \"Not enough XNA to transfer asset, perhaps your wallet has pending transactions\"\n    );\n  }\n  sendResult.debug.unspentXNAAmount =\n    unspentBaseCurrencyAmount.toLocaleString();\n\n  if (isAssetTransfer === false) {\n    if (amount > unspentBaseCurrencyAmount) {\n      throw new InsufficientFundsError(\n        \"Insufficient funds, cant send \" +\n          amount.toLocaleString() +\n          \" only have \" +\n          unspentBaseCurrencyAmount.toLocaleString()\n      );\n    }\n  }\n\n  const baseCurrencyAmountToSpend = isAssetTransfer ? 0 : amount;\n  sendResult.debug.xnaUTXOs = enoughBaseCurrencyUTXOs;\n  const inputs = blockchain.convertUTXOsToVOUT(enoughBaseCurrencyUTXOs);\n  const outputs: any = {};\n  //Add asset inputs\n\n  sendResult.debug.assetUTXOs = [] as Array<IUTXO>;\n  if (isAssetTransfer === true) {\n    if (!changeAddressAssets) {\n      throw new ValidationError(\n        \"changeAddressAssets is mandatory when transfering assets\"\n      );\n    }\n    const assetUTXOs = await addAssetInputsAndOutputs(\n      rpc,\n      addresses,\n      assetName,\n      amount,\n      inputs,\n      outputs,\n      toAddress,\n      changeAddressAssets\n    );\n    sendResult.debug.assetUTXOs = assetUTXOs;\n  } else if (isAssetTransfer === false) {\n    outputs[toAddress] = baseCurrencyAmountToSpend;\n  }\n\n  const fee = await getFee(rpc, inputs, outputs);\n  sendResult.debug.assetName = assetName;\n  sendResult.debug.fee = fee;\n  sendResult.debug.xnaAmount = 0;\n\n  const baseCurrencyChangeAmount =\n    unspentBaseCurrencyAmount - baseCurrencyAmountToSpend - fee;\n\n  sendResult.debug.xnaChangeAmount = baseCurrencyChangeAmount;\n\n  //Obviously we only add change address if there is any change\n  if (getTwoDecimalTrunc(baseCurrencyChangeAmount) > 0) {\n    outputs[changeAddress] = getTwoDecimalTrunc(baseCurrencyChangeAmount);\n  }\n  //Now we have enough UTXos, lets create a raw transactions\n  sendResult.debug.inputs = inputs;\n  sendResult.debug.outputs = outputs;\n\n  const raw = await blockchain.createRawTransaction(rpc, inputs, outputs);\n\n  sendResult.debug.rawUnsignedTransaction = raw;\n  //OK lets find the private keys (WIF) for input addresses\n\n  const privateKeys: TPrivateKey = {};\n  inputs.map(function (input: IVout_when_creating_transactions) {\n    const addy = input.address;\n    const addressObject = fromAddressObjects.find((a) => a.address === addy);\n    if (addressObject) {\n      privateKeys[addy] = addressObject.WIF;\n    }\n  });\n  sendResult.debug.privateKeys = privateKeys;\n\n  let UTXOs: Array<IUTXO> = [];\n  if (enoughBaseCurrencyUTXOs) {\n    UTXOs = UTXOs.concat(enoughBaseCurrencyUTXOs);\n  }\n\n  if (sendResult.debug.assetUTXOs) {\n    UTXOs = UTXOs.concat(sendResult.debug.assetUTXOs);\n  }\n  try {\n    const signedTransaction = sign(network, raw, UTXOs, privateKeys);\n    sendResult.debug.signedTransaction = signedTransaction;\n\n    const txid = await blockchain.sendRawTransaction(rpc, signedTransaction);\n    sendResult.transactionId = txid;\n  } catch (e) {\n    sendResult.debug.error = e;\n  }\n\n  return sendResult;\n}\n\nasync function addAssetInputsAndOutputs(\n  rpc: RPCType,\n  addresses: string[],\n  assetName: string,\n  amount: number,\n  inputs: IVout_when_creating_transactions[],\n  outputs: any,\n  toAddress: string,\n  changeAddressAssets: string\n): Promise<Array<IUTXO>> {\n  let assetUTXOs = await blockchain.getAssetUnspentTransactionOutputs(\n    rpc,\n    addresses,\n    assetName\n  );\n\n  const mempool = await blockchain.getMempool(rpc);\n  assetUTXOs = assetUTXOs.filter(\n    (UTXO) => isUTXOInMempool(mempool, UTXO) === false\n  );\n\n  const _UTXOs = getEnoughUTXOs(assetUTXOs, amount);\n  const tempInputs = blockchain.convertUTXOsToVOUT(_UTXOs);\n  tempInputs.map((item) => inputs.push(item));\n\n  outputs[toAddress] = {\n    transfer: {\n      [assetName]: amount,\n    },\n  };\n\n  const assetSum = sumOfUTXOs(_UTXOs);\n  const needsChange = assetSum - amount > 0;\n\n  if (needsChange) {\n    outputs[changeAddressAssets] = {\n      transfer: {\n        [assetName]: assetSum - amount,\n      },\n    };\n  }\n  return _UTXOs; //Return the UTXOs used for asset transfer\n}\n\nexport function getTwoDecimalTrunc(num: number) {\n  //Found answer here https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary\n  //In JavaScript the number 77866.98 minus 111 minus 0.2 equals 77755.95999999999\n  //We want it to be 77755.96\n  return Math.trunc(num * 100) / 100;\n}\nexport function getEnoughUTXOs(\n  utxos: Array<IUTXO>,\n  amount: number\n): Array<IUTXO> {\n  /*\n  Scenario ONE\n  Bob has 300 UTXO with 1 XNA each.\n  Bob has one UTXO with 400 XNA.\n\n  Bob intends to send 300 XNA\n  In this case the best thing to do is to use the single 400 UTXO\n\n  SCENARIO TWO\n\n  Alice have tons of small UTXOs like 0.03 XNA, 0.2 XNA, she wants to send 5 XNA.\n  In this case it makes sense to clean up the \"dust\", so you dont end up with a lot of small change.\n\n\n  */\n\n  //For small transactions,start with small transactions first.\n  let tempAmount = 0;\n\n  const returnValue: Array<IUTXO> = [];\n\n  utxos.map(function (utxo) {\n    if (utxo.satoshis !== 0 && tempAmount < amount) {\n      const value = utxo.satoshis / ONE_FULL_COIN;\n      tempAmount = tempAmount + value;\n      returnValue.push(utxo);\n    }\n  });\n\n  //Did we use a MASSIVE amount of UTXOs to safisfy this transaction?\n  //In this case check if we do have one single UTXO that can satisfy our needs\n  if (returnValue.length > 10) {\n    const largerUTXO = utxos.find(\n      (utxo) => utxo.satoshis / ONE_FULL_COIN > amount\n    );\n\n    if (largerUTXO) {\n      //Send this one UTXO that covers it all\n      return [largerUTXO];\n    }\n  }\n  return returnValue;\n}\n\nexport function isUTXOInMempool(\n  mempool: Array<ITransaction>,\n  UTXO: IUTXO\n): boolean {\n  function format(transactionId: string, index: number) {\n    return transactionId + \"_\" + index;\n  }\n\n  const listOfUTXOsInMempool: Array<string> = [];\n  mempool.map((transaction) => {\n    transaction.vin.map((vin) => {\n      const id = format(vin.txid, vin.vout);\n      listOfUTXOsInMempool.push(id);\n    });\n  });\n\n  const index = listOfUTXOsInMempool.indexOf(\n    format(UTXO.txid, UTXO.outputIndex)\n  );\n  const isInMempool = index > -1;\n\n  return isInMempool;\n}\n","import {\n  IUTXO,\n  IValidateAddressResponse,\n  IVout,\n  IVout_when_creating_transactions,\n  RPCType,\n} from \"../Types\";\nimport { ITransaction } from \"../Types\";\n\nconst ONE_HUNDRED_MILLION = 1e8;\n\nexport function getAddressDeltas(rpc: RPCType, addresses: string[]) {\n  return rpc(\"getaddressdeltas\", [\n    {\n      addresses: addresses,\n      assetName: \"\",\n    },\n  ]);\n}\nexport function sendRawTransaction(rpc: RPCType, signedTransaction: any) {\n\n  const p = rpc(\"sendrawtransaction\", [signedTransaction]);\n  p.catch((e: any) => {\n    console.log(\"send raw transaction\");\n    console.dir(e);\n  });\n  return p;\n}\nexport function signRawTransaction(\n  rpc: RPCType,\n  rawTransactionHex: any,\n  privateKeys: Array<string>\n) {\n  const s = rpc(\"signrawtransaction\", [\n    rawTransactionHex,\n    null,\n    privateKeys,\n  ]);\n  return s;\n}\n\nexport function decodeRawTransaction(rpc: RPCType, raw: string) {\n  return rpc(\"decoderawtransaction\", [raw]);\n}\n\nexport function getRawTransaction(rpc: RPCType, id: string): any {\n  return rpc(\"getrawtransaction\", [id, true]);\n}\nexport function createRawTransaction(\n  rpc: RPCType,\n  inputs: any,\n  outputs: any\n): Promise<string> {\n  return rpc(\"createrawtransaction\", [inputs, outputs]);\n}\n\nexport async function validateAddress(\n  rpc: RPCType,\n  address: string\n): Promise<IValidateAddressResponse> {\n  return rpc(\"validateaddress\", [address]);\n}\nexport function getBalance(\n  rpc: RPCType,\n  addresses: Array<string>\n): Promise<any> {\n  const includeAssets = true;\n  const promise = rpc(\"getaddressbalance\", [\n    { addresses: addresses },\n    includeAssets,\n  ]);\n  return promise;\n}\n\nexport function _sortUTXOs(list: Array<IUTXO>) {\n  //Remember, sort mutates the underlaying array\n  //Sort by satoshis, lowest first to prevent dust.\n  return list.sort(function (a, b) {\n    if (a.satoshis > b.satoshis) {\n      return 1;\n    }\n    if (a.satoshis < b.satoshis) {\n      return -1;\n    }\n    return 0;\n  });\n}\nexport async function getBaseCurrencyUTXOs(\n  rpc: RPCType,\n  addresses: Array<string>\n): Promise<Array<IUTXO>> {\n  const list: Array<IUTXO> = await rpc(\"getaddressutxos\", [\n    { addresses },\n  ]);\n  _sortUTXOs(list);\n  return list;\n}\nexport function getAssetUnspentTransactionOutputs(\n  rpc: RPCType,\n  addresses: Array<string>,\n  assetName: string\n): Promise<Array<IUTXO>> {\n  const assets = rpc(\"getaddressutxos\", [{ addresses, assetName }]);\n  return assets;\n}\n\nexport function getAllUnspentTransactionOutputs(\n  rpc: RPCType,\n  addresses: Array<string>\n) {\n  /*\n  Seems like getaddressutxos either return XNA UTXOs or asset UTXOs\n  Never both.\n  So we make two requests and we join the answer\n  */\n  const raven = rpc(\"getaddressutxos\", [{ addresses }]);\n  const assets = rpc(\"getaddressutxos\", [{ addresses, assetName: \"*\" }]);\n\n  return Promise.all([raven, assets]).then((values: Array<any>) => {\n    const all = values[0].concat(values[1]);\n    return all;\n  });\n}\nexport async function getMempool(rpc: RPCType): Promise<Array<ITransaction>> {\n  const ids = await rpc(\"getrawmempool\", []);\n\n  const result: any = [];\n  for (const id of ids) {\n    const transaction = await getRawTransaction(rpc, id);\n    result.push(transaction);\n  }\n  return result;\n}\nexport function convertUTXOsToVOUT(\n  UTXOs: Array<IUTXO>\n): Array<IVout_when_creating_transactions> {\n  const inputs = UTXOs.map(function (bla) {\n    //OK we have to convert from \"unspent\" format to \"vout\"\n\n    const obj = {\n      txid: bla.txid,\n      vout: bla.outputIndex,\n      address: bla.address,\n    };\n    return obj;\n  });\n  return inputs;\n}\n","export class ValidationError extends Error {\n  constructor(message:string) {\n    super(message); // (1)\n    this.name = \"ValidationError\"; // (2)\n  }\n}\nexport class InvalidAddressError  extends Error {\n  constructor(message:string) {\n    super(message); // (1)\n    this.name = \"InvalidAddressError\"; // (2)\n  }\n}\n\n\n  export class InsufficientFundsError extends Error {\n    constructor(message:string) {\n      super(message); // (1)\n      this.name = \"InsufficientFundsError\"; // (2)\n    }\n  }\n\n  ","import NeuraiKey, { Network } from \"@neuraiproject/neurai-key\";\nimport Signer from \"@neuraiproject/neurai-sign-transaction\";\n\nimport { Wallet } from \"../neuraiWallet\";\nimport { IInput, SweepResult } from \"../Types\";\nimport { getTwoDecimalTrunc } from \"./Transactor\";\n\n//sight rate burger maid melody slogan attitude gas account sick awful hammer\n//OH easter egg ;)\nconst WIF = \"Kz5U4Bmhrng4o2ZgwBi5PjtorCeq2dyM7axGQfdxsBSwCKi5ZfTw\";\n\n/**\n *\n * @param WIF the private key in wallet import format that you want to sweep/empty\n * @param wallet your wallet\n * @returns a string of a signed transaction, you have to broad cast it\n */\nexport async function sweep(\n  WIF: string,\n  wallet: Wallet,\n  onlineMode: boolean\n): Promise<SweepResult> {\n  const privateKey = NeuraiKey.getAddressByWIF(wallet.network, WIF);\n\n  const result: SweepResult = {};\n  const rpc = wallet.rpc;\n  const obj = {\n    addresses: [privateKey.address],\n  };\n  const baseCurrencyUTXOs = await rpc(\"getaddressutxos\", [obj]);\n  const obj2 = {\n    addresses: [privateKey.address],\n    assetName: \"*\",\n  };\n\n  const assetUTXOs = await rpc(\"getaddressutxos\", [obj2]);\n  const UTXOs = assetUTXOs.concat(baseCurrencyUTXOs);\n  result.UTXOs = UTXOs;\n  //Create a raw transaction with ALL UTXOs\n\n  if (UTXOs.length === 0) {\n    result.errorDescription =\n      \"Address \" + privateKey.address + \" has no funds\";\n    return result;\n  }\n  const balanceObject = {};\n\n  UTXOs.map((utxo) => {\n    if (!balanceObject[utxo.assetName]) {\n      balanceObject[utxo.assetName] = 0;\n    } \n    balanceObject[utxo.assetName] += utxo.satoshis;\n  });\n\n  const keys = Object.keys(balanceObject);\n\n  //Start simple, get the first addresses from the wallet\n\n  const outputs = {};\n\n  const fixedFee = 0.02; // should do for now\n  keys.map((assetName, index) => {\n    const address = wallet.getAddresses()[index];\n    const amount = balanceObject[assetName] / 1e8;\n\n    if (assetName === wallet.baseCurrency) {\n      outputs[address] = getTwoDecimalTrunc(amount - fixedFee);\n    } else {\n      outputs[address] = {\n        transfer: {\n          [assetName]: amount,\n        },\n      };\n    }\n  });\n  result.outputs = outputs;\n\n  //Convert from UTXO format to INPUT fomat\n  const inputs: Array<IInput> = UTXOs.map((utxo, index) => {\n    /*   {\n         \"txid\":\"id\",                      (string, required) The transaction id\n         \"vout\":n,                         (number, required) The output number\n         \"sequence\":n                      (number, optional) The sequence number\n       } \n       */\n\n    const input: IInput = {\n      txid: utxo.txid,\n      vout: utxo.outputIndex,\n    };\n    return input;\n  });\n  //Create raw transaction\n  const rawHex = await rpc(\"createrawtransaction\", [inputs, outputs]);\n\n  const privateKeys = {\n    [privateKey.address]: WIF,\n  };\n  const signedHex = Signer.sign(wallet.network, rawHex, UTXOs, privateKeys);\n  result.rawTransaction = signedHex;\n  if (onlineMode === true) {\n    result.transactionId = await rpc(\"sendrawtransaction\", [signedHex]);\n  }\n\n  return result;\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}